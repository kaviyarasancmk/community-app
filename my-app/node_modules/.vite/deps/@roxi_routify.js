import {
  derived,
  writable
} from "./chunk-HPNWXQCZ.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  __publicField,
  add_location,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_attributes,
  space,
  subscribe,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-IOE5GSZZ.js";

// node_modules/@roxi/routify/lib/runtime/Route/utils.js
var uriDecodeStringOrArray = (strOrArr) => strOrArr instanceof Array ? (
  /** @type {T} */
  strOrArr.map(decodeURI)
) : (
  /** @type {T} */
  decodeURI(strOrArr)
);
var URIDecodeObject = (obj) => Object.entries(obj).reduce(
  (_return, [key, value]) => ({
    ..._return,
    [key]: uriDecodeStringOrArray(value)
  }),
  {}
);

// node_modules/@roxi/routify/lib/runtime/Route/RouteFragment.js
var RouteFragment = class {
  /**
   * @param {Route} route the route this fragment belongs to
   * @param {RNodeRuntime} node the node that corresponds to the fragment
   * @param {String=} urlFragment a fragment of the url (fragments = url.split('/'))
   * @param {Object<string, any>=} params
   */
  constructor(route, node2, urlFragment = "", params2 = {}) {
    /**
     * @type {Object.<string, string|string[]>}
     **/
    __publicField(this, "_params", {});
    this.route = route;
    this.node = node2;
    this.load = void 0;
    this.urlFragment = urlFragment;
    this.params = params2;
    this.renderContext = writable();
    Object.defineProperty(this, "route", { enumerable: false });
  }
  get index() {
    return this.route.fragments.indexOf(this);
  }
  get params() {
    return URIDecodeObject(this._params);
  }
  set params(params2) {
    this._params = params2;
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/Route.js
var URL_STATES = ["pushState", "replaceState", "popState"];
var Route = class {
  /**
   * @param {Router} router
   * @param {string} url
   * @param {UrlState} mode
   * @param {Object} state a state to attach to the route
   */
  constructor(router, url2, mode, state = {}) {
    /** @type {RouteFragment[]} */
    __publicField(this, "allFragments", []);
    /** @type {Promise<{route: Route}>} */
    __publicField(this, "loaded");
    /** @type {RoutifyLoadReturn} */
    __publicField(this, "load", {
      status: 200,
      error: null,
      maxage: null,
      props: {},
      redirect: null
    });
    const [, hash] = url2.match(/#(.+)/) || [];
    this.router = router;
    this.url = url2;
    this.mode = mode;
    this.state = state;
    this.hash = hash;
    this.state.createdAt = /* @__PURE__ */ new Date();
    if (!router.rootNode) {
      this.router.log.error("Can't navigate without a rootNode");
      const err = new Error("Can't navigate without a rootNode");
      Object.assign(err, { routify: { router } });
      throw err;
    }
    if (!URL_STATES.includes(mode))
      throw new Error("url.mode must be pushState, replaceState or popState");
    this.allFragments = this._createFragments();
    this.log = router.log.createChild("[route]");
    this.log.debug("created", this);
  }
  /** @type {RouteFragment[]} only fragments with components */
  get fragments() {
    return this.router.transformFragments.run(this.allFragments);
  }
  get params() {
    const match = this.url.match(/\?.+/);
    const query = match && match[0] || "";
    return Object.assign(
      {},
      ...this.allFragments.map((fragment) => fragment.params),
      this.router.queryHandler.parse(query, this)
    );
  }
  get leaf() {
    return [...this.allFragments].pop();
  }
  get isPending() {
    return this === this.router.pendingRoute.get();
  }
  async loadRoute() {
    const { router } = this;
    const pipeline = [
      this.runBeforeUrlChangeHooks,
      this.loadComponents,
      this.runPreloads
    ];
    this.loaded = new Promise(async (resolve, reject) => {
      for (const pretask of pipeline) {
        const passedPreTask = await pretask.bind(this)();
        if (!router.pendingRoute.get()) {
          resolve({ route: router.activeRoute.get() });
          return;
        } else if (!this.isPending) {
          router.pendingRoute.get().loaded.then(resolve).catch(reject);
          return;
        } else if (!passedPreTask) {
          router.pendingRoute.set(null);
          return;
        }
      }
      this.router.log.debug("set active route", this);
      const $activeRoute = this.router.activeRoute.get();
      if ($activeRoute)
        router.history.push($activeRoute);
      router.activeRoute.set(this);
      router.afterUrlChange.run({
        route: this,
        history: [...router.history].reverse()
      });
      this.router.log.debug("unset pending route", this);
      router.pendingRoute.set(null);
      resolve({ route: this });
    });
    return this.loaded;
  }
  /**
   * converts async module functions to sync functions
   */
  async loadComponents() {
    this.log.debug("load components", this);
    const nodes = this.fragments.map((fragment) => fragment.node);
    const multiNodes = nodes.map((node2) => node2.children.find((node3) => node3.name === "_decorator")).filter(Boolean);
    await Promise.all([...nodes, ...multiNodes].map((node2) => node2.loadModule()));
    return true;
  }
  async runPreloads() {
    var _a;
    this.log.debug("run preloads", this);
    const prevRoute = this.router.activeRoute.get();
    for (const [index, fragment] of this.fragments.entries()) {
      if (!this.isPending)
        return false;
      const prevFragmentInSpot = prevRoute == null ? void 0 : prevRoute.fragments[index];
      const isSameBranch = fragment.node === (prevFragmentInSpot == null ? void 0 : prevFragmentInSpot.node);
      const ctx = {
        route: this,
        prevRoute,
        isNew: !isSameBranch
      };
      if ((_a = fragment.node.module) == null ? void 0 : _a.load) {
        fragment.load = {
          ...isSameBranch && prevFragmentInSpot.load,
          ...await fragment.node.module.load(ctx)
        };
        Object.assign(this.load, fragment.load);
        if (this.load.redirect)
          return this.router.url.replace(this.load.redirect, {
            redirectedBy: this
          });
      }
    }
    return this;
  }
  async runBeforeUrlChangeHooks() {
    return await this.router.beforeUrlChange.run({ route: this });
  }
  /**
   * @param {RNodeRuntime} node the node that corresponds to the fragment
   * @param {String=} urlFragment a fragment of the url (fragments = url.split('/'))
   * @param {Object<string, any>=} params
   */
  createFragment(node2, urlFragment = "", params2 = {}) {
    return new RouteFragment(this, node2, urlFragment, params2);
  }
  /**
   * creates fragments. A fragment is the section between each / in the URL
   */
  _createFragments() {
    const url2 = this.url.replace(/[#?].+/, "");
    const rootNode = this.router.rootNode;
    const nodeChain = this.router.rootNode.getChainTo(url2, {
      rootNode,
      allowDynamic: true,
      includeIndex: true
    });
    const fragments = nodeChain.map(
      (nc) => this.createFragment(nc.node, nc.fragment, nc.params)
    );
    return fragments;
  }
};

// node_modules/consolite/esm/index.mjs
var defaults = {
  filter: "",
  level: 3,
  levels: {
    default: 3,
    error: 1,
    warn: 2,
    debug: 4,
    trace: 4
  }
};
var noop2 = (x) => x;
var unique = (v, i, a) => a.indexOf(v) === i;
var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeIfString = (str) => typeof str === "string" ? escapeRegExp(str) : str;
var Consolite = class {
  constructor(...prefix) {
    __publicField(this, "prefix", []);
    __publicField(this, "_filter", null);
    __publicField(this, "_level", null);
    __publicField(this, "_levels", {});
    __publicField(this, "parent", null);
    __publicField(this, "levels", new Proxy(this._levels, {
      ownKeys: (target) => {
        var _a;
        return [
          ...Object.keys(defaults.levels),
          ...Object.keys(((_a = this.parent) == null ? void 0 : _a.levels) || {}),
          ...Reflect.ownKeys(target)
        ].filter(unique);
      },
      getOwnPropertyDescriptor: (target, key) => ({
        value: target[key],
        enumerable: true,
        configurable: true
      }),
      get: (target, prop) => {
        var _a, _b;
        return target[prop] || target.default || ((_a = this.parent) == null ? void 0 : _a.levels[prop]) || ((_b = this.parent) == null ? void 0 : _b.levels.default) || defaults.levels[prop] || defaults.levels.default;
      },
      set: (target, prop, value) => target[prop] = value
    }));
    __publicField(this, "create", createLogger);
    this.prefix.push(...prefix);
    const withinLevel = (prop) => this.levels[prop] <= this.level;
    const passesFilter = () => typeof this.filter === "function" ? this.filter(prefix) : prefix.join("").match(escapeIfString(this.filter));
    this.register = (prop, fn) => Object.defineProperty(this, prop, {
      get: () => {
        const canBind = typeof fn === "function";
        const shouldPrint = withinLevel(prop) && passesFilter() && canBind;
        const prefixes = prefix.map((p) => typeof p === "string" ? p : p(prop, this));
        return shouldPrint ? fn.bind(console, ...prefixes) : noop2;
      }
    });
    Object.keys(console).forEach((prop) => this.register(prop, console[prop]));
  }
  get level() {
    var _a;
    return this._level ?? ((_a = this.parent) == null ? void 0 : _a.level) ?? defaults.level;
  }
  set level(val) {
    this._level = val;
  }
  get filter() {
    var _a;
    return this._filter ?? ((_a = this.parent) == null ? void 0 : _a.filter) ?? defaults.filter;
  }
  set filter(val) {
    this._filter = val;
  }
  get root() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.root) || this;
  }
  createChild(...prefix) {
    const child = createLogger(...this.prefix, ...prefix);
    child.parent = this;
    return child;
  }
  createParent(...prefix) {
    return createLogger(...prefix, ...this.prefix);
  }
};
var createLogger = (...prefix) => Object.assign(new Consolite(...prefix));

// node_modules/@roxi/routify/lib/runtime/utils/logger.js
var log = createLogger("[rf3]");
var createRootLogger = () => {
  Object.assign(log, loadState());
  return new Proxy(log, {
    get: (target, prop) => target[prop],
    set: (target, prop, value) => {
      target[prop] = value;
      saveState(log);
      return false;
    }
  });
};
var loadState = () => {
  if (typeof window === "undefined") {
    const level = process.env.DEBUG_LEVEL;
    const filter = process.env.DEBUG_FILTER;
    return { level, filter };
  } else {
    return JSON.parse(localStorage.getItem("__routify.logState") || "{}");
  }
};
var saveState = (log2) => {
  const { level, filter } = log2;
  if (typeof window === "undefined") {
    process.env.DEBUG_LEVEL = level;
    process.env.DEBUG_FILTER = filter;
  } else
    localStorage.setItem("__routify.logState", JSON.stringify({ filter, level }));
};
var debugWrapper = (fn, msg) => (
  /** @ts-ignore */
  (...params2) => {
    const result = fn(...params2);
    log.debug(msg, { params: params2, result });
    return result;
  }
);

// node_modules/@roxi/routify/lib/runtime/Global/BrowserAdapter.js
var createBrowserAdapter = (opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) || ";";
  return {
    // Called by each router when the browser URL changes. Returns an internal URL for each respective router.
    toRouter: (url2, router) => {
      const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`;
      const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`);
      const matches = url2.match(RE);
      return matches ? matches[2] : "/";
    },
    // compiles all router URLS into a single URL for the browser.
    toBrowser: (routers) => routers.map((r) => (r.name ? `${r.name}=` : "") + r.url.external()).join(delimiter)
  };
};

// node_modules/@roxi/routify/lib/runtime/Global/Global.js
var AppInstance = class {
  constructor() {
    /** @type {RoutifyRuntime[]} */
    __publicField(this, "instances", []);
    __publicField(this, "browserAdapter", createBrowserAdapter());
    /** @param {Router} router */
    __publicField(this, "urlFromBrowser", (router) => {
      if (debugWrapper)
        return debugWrapper(
          this.browserAdapter.toRouter,
          "calling browserAdapter.toRouter"
        )(urlFromAddress(), router);
      return this.browserAdapter.toRouter(urlFromAddress(), router);
    });
    globalThis["__routify"] = this;
    this.log = createRootLogger();
  }
  /** @type {Router[]} */
  get routers() {
    return [].concat(...this.instances.map((instance8) => instance8.routers));
  }
  register(instance8) {
    this.instances.push(instance8);
    return this;
  }
};
var appInstance = new AppInstance();

// node_modules/@roxi/routify/lib/runtime/utils/index.js
var getUrlFromClick = (event) => {
  const el = event.target.closest("a");
  const href = el && el.href;
  if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.key && event.key !== "Enter" || event.defaultPrevented)
    return;
  if (!href || el.target || el.host !== location.host)
    return;
  const url2 = new URL(href);
  const relativeUrl = url2.pathname + url2.search + url2.hash;
  event.preventDefault();
  return relativeUrl;
};
var pathAndParamsToUrl = (path, params2 = {}, queryHandler, useWildcards) => {
  Object.entries(params2).forEach(([key, val]) => {
    if (path.includes(`[${key}]`)) {
      path = path.replace(`[${key}]`, val);
      delete params2[key];
    }
  });
  if (useWildcards)
    path = insertWildcards(path);
  return path + queryHandler(params2);
};
var insertWildcards = (str) => {
  return str.replace(/\[.*?\]/, ".*?");
};
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
var populateUrl = (path, params2, route) => {
  const overloads = {};
  Object.entries(params2).forEach(([param, value]) => {
    const RE = new RegExp(`\\[(...)?${param}\\]|\\:${param}`);
    value = Array.isArray(value) ? value.join("/") : value;
    if (path.match(RE))
      path = path.replace(RE, encodeURI(value));
    else
      overloads[param] = value;
  });
  const query = route.router.queryHandler.stringify(overloads, route);
  return path + query;
};
var urlFromAddress = () => (({ pathname, search, hash }) => pathname + search + hash)(window.location);
var getGlobalContext = () => {
  console.log("Using helpers outside router context is not supported. Use at own risk.");
  const router = appInstance.routers[0];
  const route = router.activeRoute.get() || router.pendingRoute.get();
  return {
    elem: null,
    anchorLocation: null,
    options: null,
    childFragments: writable(route.allFragments),
    node: router.rootNode,
    fragment: route.allFragments[0],
    isActive: writable(false),
    isVisible: writable(false),
    multi: null,
    router,
    route,
    parentContext: null,
    onDestroy: null,
    decorators: [],
    single: writable(true),
    scrollBoundary: null
  };
};
var contexts = {
  /** @type {Router} */
  get router() {
    return (getContext("routify-fragment-context") || getGlobalContext()).router;
  },
  /** @type {RenderContext} */
  get fragment() {
    return getContext("routify-fragment-context") || getGlobalContext();
  }
};
var getContextMaybe = (name) => {
  try {
    return getContext(name);
  } catch (err) {
  }
};
var getable = (value, start) => {
  const store = writable(value, start);
  return Object.assign(store, { get: () => get_store_value(store) });
};
var identicalRoutes = (...routes) => routes.map((route) => JSON.stringify([route == null ? void 0 : route.allFragments, route == null ? void 0 : route.url])).reduce((prev, curr) => prev === curr && curr);
var isAnonFn = (input) => typeof input === "function" && !input.prototype;
var resolveIfAnonFn = (input) => (
  // @ts-ignore
  (...payload) => (
    // @ts-ignore
    isAnonFn(input) ? input(...payload) : input
  )
);
var pushToOrReplace = (arr, input) => {
  const _isAnonFn = isAnonFn(input);
  input = _isAnonFn || Array.isArray(input) ? input : [input];
  const res = _isAnonFn ? input([...arr]) : [...arr, ...input];
  if (!Array.isArray(res))
    throw new Error("anonymous callback did not return array");
  return res;
};
var waitFor = (store, cb) => new Promise((resolve, reject) => {
  try {
    const unsub = store.subscribe((val) => {
      if (cb(val)) {
        resolve(val);
        setTimeout(() => unsub);
      }
    });
  } catch (err) {
    reject(err);
  }
});

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js
var BaseReflector = class {
  /** @param {Router} router */
  constructor(router) {
    this.router = router;
    this.log = this.router.log;
  }
  install() {
  }
  uninstall() {
  }
  reflect() {
  }
};

// node_modules/@roxi/routify/lib/common/RNode.js
var RNode = class {
  /**
   * @param {string} name
   * @param {ReservedCmpProps|string} module
   * @param {InstanceType} instance
   */
  constructor(name, module, instance8) {
    /** @type {InstanceType['NodeType']} */
    __publicField(this, "parent");
    /** @type {Object.<string, any>} */
    __publicField(this, "meta", {});
    /** @type {String} */
    __publicField(this, "id");
    /** @type {Object.<string,RegExp>} */
    __publicField(this, "_regex", {});
    /**
     * @type {Object.<string, string[]>}
     * */
    __publicField(this, "_paramKeys", {});
    this.instance = instance8;
    this.name = name;
    instance8.nodeIndex.push(this);
    this.module = module;
    Object.defineProperty(this, "instance", { enumerable: false });
    Object.defineProperty(this, "parent", { enumerable: false });
  }
  /** @param {InstanceType['NodeConstructor']['prototype']} child */
  appendChild(child) {
    if (child.instance)
      child.parent = this;
  }
  /**
   * Creates a new child node
   * Same as `node.appendChild(instance.createNode('my-node'))`
   * @param {string} name
   */
  createChild(name, module) {
    const node2 = (
      /** @type {InstanceType['NodeConstructor']['prototype']} */
      this.instance.createNode(name, module)
    );
    this.appendChild(node2);
    return node2;
  }
  /** @type {InstanceType['NodeConstructor']['prototype'][]} */
  get descendants() {
    return this.instance.nodeIndex.filter(
      (node2) => node2.ancestors.find((n) => n === this)
    );
  }
  remove() {
    const { nodeIndex } = this.instance;
    const index = nodeIndex.findIndex((node2) => node2 === this);
    nodeIndex.splice(index, 1);
  }
  /** @type {InstanceType['NodeConstructor']['prototype'][]} */
  get ancestors() {
    let node2 = this;
    const ancestors = [];
    while (node2 = node2.parent)
      ancestors.push(node2);
    return ancestors;
  }
  /** @type {InstanceType['NodeConstructor']['prototype']} */
  get root() {
    let node2 = this;
    while (node2.parent)
      node2 = node2.parent;
    return node2;
  }
  get isRoot() {
    return this === this.root;
  }
  /** @type {InstanceType['NodeType'][]} */
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this);
  }
  /** @returns {number} */
  get level() {
    var _a;
    return (((_a = this.parent) == null ? void 0 : _a.level) || 0) + 1;
  }
  get regex() {
    const { name } = this;
    if (!this._regex[name])
      this._regex[name] = this.instance.utils.getRegexFromName(this.name);
    return this._regex[name];
  }
  // save to regex key so regex gets invalidated if name changes
  set regex(value) {
    this._regex[this.name] = new RegExp(value);
  }
  get paramKeys() {
    const { name } = this;
    if (!this._paramKeys[name])
      this._paramKeys[name] = this.instance.utils.getFieldsFromName(this.name);
    return this._paramKeys[name];
  }
  /**
   * returns parameters for a given urlFragment
   * @param {string} urlFragment
   */
  getParams(urlFragment) {
    if (urlFragment.match(/^\.+$/))
      return {};
    const values = this.instance.utils.getValuesFromPath(this.regex, urlFragment);
    return this.instance.utils.mapFieldsWithValues(this.paramKeys, values);
  }
  // todo traverse should use the getChainTo API interface
  /**
   * resolve a node relative to this node
   * @param {string} path
   * @param {boolean} allowDynamic allow traversing dynamic components (parameterized)
   * @param {boolean} includeIndex
   * @param {boolean} silent don't throw errors for 404s
   * @returns {this}
   */
  traverse(path, allowDynamic = false, includeIndex = false, silent = false) {
    var _a;
    const isNamed = !path.startsWith("/") && !path.startsWith(".");
    return isNamed ? this.root.instance.nodeIndex.find((node2) => node2.meta.name === path) : (_a = this.getChainTo(path, { allowDynamic, includeIndex, silent })) == null ? void 0 : _a.pop().node;
  }
  /**
   * Returns an array of steps to reach a path. Each path contains a node and params
   * @param {string} path
   * @param {object} [options]
   * @param {boolean} [options.allowDynamic=true]
   * @param {boolean} [options.includeIndex=true]
   * @param {boolean} [options.silent=false] don't throw errors for 404s
   * @param {this} [options.rootNode]
   
   */
  getChainTo(path, options) {
    options = {
      ...{ allowDynamic: true, includeIndex: true },
      ...options
    };
    const originNode = path.startsWith("/") ? options.rootNode || this.root : this;
    const stepsToLeaf = path.split("/").filter((snip) => snip !== ".").filter(Boolean);
    let currentNodeStep = {
      node: originNode,
      stepsToLeaf,
      params: {},
      fragment: ""
    };
    const nodeSteps = [currentNodeStep];
    let inStaticDeadEnd = false;
    let inDynamicDeadEnd = false;
    while (currentNodeStep.stepsToLeaf.length) {
      const [nextStep, ...restSteps] = currentNodeStep.stepsToLeaf;
      const nextNode = nextStep === ".." ? currentNodeStep.node.parent : !inStaticDeadEnd && currentNodeStep.node.children.find(
        (node2) => node2.name === nextStep
      ) || options.allowDynamic && !inDynamicDeadEnd && currentNodeStep.node.children.filter(({ meta: meta2 }) => meta2.dynamic && !meta2.dynamicSpread).find((node2) => node2.regex.test(nextStep)) || options.allowDynamic && currentNodeStep.node.children.find(
        (node2) => node2.meta.dynamicSpread
      );
      if (nextNode) {
        const nodeStep = {
          node: nextNode,
          params: nextNode.meta.dynamicSpread ? [nextStep] : nextNode.meta.dynamic ? nextNode.getParams(nextStep) : {},
          stepsToLeaf: restSteps,
          fragment: nextStep
        };
        currentNodeStep = nodeStep;
        nodeSteps.push(nodeStep);
      } else if (!options.allowDynamic && options.silent)
        return null;
      else if (!options.allowDynamic && !options.silent)
        throw new Error(
          `${nodeSteps.map((ns) => ns.node.name || "root").join("/")} could not travel to ${nextStep}`
        );
      else if (currentNodeStep.node.meta.dynamicSpread) {
        currentNodeStep.params.push(nextStep);
        currentNodeStep.fragment += `/${nextStep}`;
        currentNodeStep.stepsToLeaf.shift();
        inDynamicDeadEnd = false;
        inStaticDeadEnd = false;
      } else {
        nodeSteps.pop();
        currentNodeStep = [...nodeSteps].pop();
        inDynamicDeadEnd = inStaticDeadEnd;
        inStaticDeadEnd = true;
        if (!currentNodeStep && options.silent)
          return null;
        else if (!currentNodeStep && !options.silent)
          throw new Error(`Could not find path "${path}" from ${this.name}`);
      }
    }
    try {
      const indexNode = options.includeIndex && currentNodeStep.node.traverse("./index");
      if (indexNode)
        nodeSteps.push({
          node: indexNode,
          stepsToLeaf: [],
          params: {},
          fragment: ""
        });
    } catch (err) {
    }
    nodeSteps.forEach((ns) => {
      ns.params = Array.isArray(ns.params) ? { [ns.node.name.replace(/\[\.\.\.(.+)\]/, "$1")]: ns.params } : ns.params;
    });
    return nodeSteps;
  }
  /** @returns {InstanceType['NodeConstructor']['prototype']} */
  toJSON() {
    return {
      ...this,
      children: [...this.children]
    };
  }
  /** @returns {string} */
  get path() {
    return "/" + [this, ...this.ancestors].reverse().map((node2) => node2.name).filter(Boolean).join("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/Node.svelte
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let component;
  let current;
  const component_spread_levels = [
    /*passthrough*/
    ctx[0],
    { context: (
      /*context*/
      ctx[2]
    ) }
  ];
  let component_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < component_spread_levels.length; i += 1) {
    component_props = assign(component_props, component_spread_levels[i]);
  }
  component = new /*Component*/
  ctx[1]({ props: component_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = dirty & /*passthrough, context*/
      5 ? get_spread_update(component_spread_levels, [
        dirty & /*passthrough*/
        1 && get_spread_object(
          /*passthrough*/
          ctx2[0]
        ),
        dirty & /*context*/
        4 && { context: (
          /*context*/
          ctx2[2]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      32) {
        component_changes.$$scope = { dirty, ctx: ctx2 };
      }
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(15:0) {#if Component}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(16:4) <Component {...passthrough} {context}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*Component*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var CTX = "routify-fragment-context";
function instance($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Node", slots, ["default"]);
  let { node: node2 } = $$props;
  let { passthrough } = $$props;
  const context2 = { ...getContext(CTX), node: node2 };
  setContext(CTX, context2);
  let Component = (_a = node2.module) == null ? void 0 : _a.default;
  if (!Component && node2.asyncModule)
    node2.asyncModule().then((r) => $$invalidate(1, Component = r.default));
  $$self.$$.on_mount.push(function() {
    if (node2 === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<Node> was created without expected prop 'node'");
    }
    if (passthrough === void 0 && !("passthrough" in $$props || $$self.$$.bound[$$self.$$.props["passthrough"]])) {
      console.warn("<Node> was created without expected prop 'passthrough'");
    }
  });
  const writable_props = ["node", "passthrough"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Node> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    node: node2,
    passthrough,
    CTX,
    context: context2,
    Component
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [passthrough, Component, context2, node2, slots, $$scope];
}
var Node = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { node: 3, passthrough: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Node",
      options,
      id: create_fragment.name
    });
  }
  get node() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Node_default = Node;

// node_modules/@roxi/routify/lib/runtime/Instance/RNodeRuntime.js
var RNodeRuntime = class extends RNode {
  /**
   * @param {string} name
   * @param {ReservedCmpProps} module
   * @param {RoutifyRuntime} instance
   * @param {LoadSvelteModule=} asyncModule
   */
  constructor(name, module, instance8, asyncModule) {
    super(name, module, instance8);
    /** @type {LoadSvelteModule} */
    __publicField(this, "asyncModule");
    /**
     * @param {object} snapshotRoot
     */
    __publicField(this, "importTree", (snapshotRoot) => {
      const queue = [[this, snapshotRoot]];
      while (queue.length) {
        const [node2, snapshot] = queue.pop();
        const { children: children2, ...nodeSnapshot } = snapshot;
        Object.assign(node2, nodeSnapshot);
        for (const childSnapshot of children2) {
          const childNode = node2.createChild(
            snapshot.name || snapshot.rootName || ""
          );
          queue.push([childNode, childSnapshot]);
        }
      }
      return this;
    });
    this.module = module;
    this.asyncModule = asyncModule;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this).sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0));
  }
  get pages() {
    return this.pagesWithIndex.filter((node2) => node2.name !== "index");
  }
  get pagesWithIndex() {
    return this.children.filter((node2) => !node2.meta.fallback).filter((node2) => !node2.name.startsWith("_")).filter((node2) => !node2.name.includes("[")).filter((node2) => {
      var _a;
      return !(((_a = node2.meta) == null ? void 0 : _a.order) === false);
    });
  }
  get hasComponent() {
    return !!(this.module || this.asyncModule);
  }
  /** @ts-ignore SvelteComponentConstructor is only available in VSCode */
  /** @returns {Promise<SvelteComponentDev>} */
  async getRawComponent() {
    const module = await this.loadModule();
    return module == null ? void 0 : module.default;
  }
  async loadModule() {
    if (!this.module && this.asyncModule) {
      this.module = await this.asyncModule();
    }
    return this.module;
  }
  /**
   * Returns in a sync/async component in a synchronous wrapper
   * @returns {() => Node}
   **/
  get component() {
    const node2 = this;
    return function(options) {
      options.props = {
        ...options.props,
        passthrough: options.props,
        node: node2
      };
      return new Node_default({ ...options });
    };
  }
  get _fallback() {
    var _a;
    return this.children.find((node2) => node2.meta.fallback) || ((_a = this.parent) == null ? void 0 : _a._fallback);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/UrlParamUtils.js
var defaultRe = /\[(.+?)\]/gm;
var UrlParamUtils = class {
  constructor(RE = defaultRe) {
    /**
     * returns ["slug", "id"] from "my[slug]and[id]"
     * @param {string} name
     * @returns {string[]}
     */
    __publicField(this, "getFieldsFromName", (name) => [...name.matchAll(this.RE)].map((v) => v[1]));
    /**
     * converts "my[slug]and[id]" to /my(.+)and(.+)/gm
     * @param {string} name
     * @returns {RegExp}
     */
    __publicField(this, "getRegexFromName", (name) => new RegExp("^" + name.replace(this.RE, "(.+)") + "$"));
    /**
     * returns an array of values matching a regular expression and path
     * @param {RegExp} re
     * @param {string} path
     * @returns {string[]}
     */
    __publicField(this, "getValuesFromPath", (re, path) => (path.match(re) || []).slice(1));
    /**
     * converts (['a', 'b', 'c'], [1, 2, 3]) to {a: 1, b: 2, c: 3}
     * @param {string[]} fields
     * @param {string[]} values
     * @returns
     */
    __publicField(this, "mapFieldsWithValues", (fields, values) => this.haveEqualLength(fields, values) && fields.reduce((map, field, index) => {
      map[field] = values[index];
      return map;
    }, {}));
    __publicField(this, "haveEqualLength", (fields, values) => {
      if (fields.length !== values.length)
        throw new Error(
          `fields and values should be of same length
fields: ${JSON.stringify(fields)}
values: ${JSON.stringify(values)}`
        );
      return true;
    });
    this.RE = RE;
  }
};

// node_modules/@roxi/routify/lib/common/Routify.js
var Routify = class {
  constructor() {
    /** @type {typeof RNode<any>} */
    __publicField(this, "NodeConstructor");
    /** @type {NodeConstructor['prototype']} */
    __publicField(this, "NodeType");
    /** @type {NodeConstructor['prototype'][]} */
    __publicField(this, "nodeIndex", []);
    /** @type {Object<string, NodeConstructor['prototype']>} */
    __publicField(this, "rootNodes", {});
    __publicField(this, "utils", new UrlParamUtils());
  }
  /**
   * @param {string=} name relative path for the node
   * @param {any|string=} module svelte component
   * @returns {this['NodeType']}
   */
  createNode(name, module) {
    return new this.NodeConstructor(name, module, this);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js
var RoutifyRuntime = class extends Routify {
  constructor(options) {
    super();
    __publicField(this, "NodeConstructor", RNodeRuntime);
    __publicField(this, "mode", "runtime");
    /**@type {Router[]} routers this instance belongs to */
    __publicField(this, "routers", []);
    /** @type {Object<string, RNodeRuntime>} */
    __publicField(this, "rootNodes", {});
    this.options = options;
    if (options.routes) {
      this.rootNodes[options.routes.rootName || "unnamed"] = this.createNode(
        options.routes.rootName
      ).importTree(options.routes);
    }
    this.global = appInstance.register(this);
    Object.defineProperty(this, "routers", { enumerable: false });
    this.log = this.global.log;
  }
};

// node_modules/hookar/esm/util.mjs
var runOnce = (cb) => {
  let hasRun;
  const wrapper = (...params2) => {
    if (hasRun)
      return;
    hasRun = true;
    return cb(...params2);
  };
  return (
    /** @type {CB} */
    wrapper
  );
};

// node_modules/hookar/esm/index.mjs
var createHooksCollection = (runner) => {
  const hooks = [];
  const hooksCollection = (hook) => {
    hooks.push(hook);
    return () => hooks.splice(hooks.indexOf(hook), 1);
  };
  hooksCollection.hooks = hooks;
  hooksCollection.run = runner(hooks);
  hooksCollection.runOnce = runOnce(runner(hooks));
  return hooksCollection;
};
var createPipelineCollection = (type) => (
  // @ts-ignore
  createHooksCollection(
    (hooks) => (value, ...rest) => hooks.reduce(
      (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => hook(r, ...rest)) : hook(pipedValue, ...rest),
      value
    )
  )
);
var createSequenceHooksCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (last, hook) => (last == null ? void 0 : last.then) ? last.then((_) => hook(value, ...rest)) : hook(value, ...rest),
    value
  )
);
var createGuardsCollection = (type) => (
  // @ts-ignore
  createHooksCollection(
    (hooks) => (value, ...rest) => hooks.reduce(
      (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => r && hook(value, ...rest)) : pipedValue && hook(value, ...rest),
      value || true
    )
  )
);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Address.js
var AddressReflector = class extends BaseReflector {
  /** @param {Router} router */
  constructor(router) {
    super(router);
    __publicField(this, "reflect", () => {
      const { mode } = get_store_value(this.router.activeRoute);
      if (mode === "popState")
        return false;
      const { routers, browserAdapter } = this.router.instance.global;
      const addressRouters = routers.filter(
        (router) => router.urlReflector instanceof this.constructor
      );
      const url2 = browserAdapter.toBrowser(addressRouters);
      this.log.debug("pushing internal url to browser history", {
        mode,
        url: url2,
        currentBrowserUrl: urlFromAddress(),
        currentInternalUrl: this.router.url.internal()
      });
      history[`${mode}Native`]({}, "", url2);
    });
    const { instance: instance8, urlRewrites } = router;
    const { urlFromBrowser, browserAdapter } = instance8.global;
    if (!history["onPushstate"]) {
      this.log.debug("polyfill history hooks");
      polyfillHistory();
    }
    const createStateEventHandler = (method) => {
      return function(data, title, url2) {
        var _a;
        const routerName = ((_a = data == null ? void 0 : data.routify) == null ? void 0 : _a.router) ?? false;
        if (routerName === false)
          url2 = browserAdapter.toRouter(url2, router);
        else if (routerName !== router.name)
          return false;
        for (const rewrite of urlRewrites)
          url2 = rewrite.toInternal(url2, { router });
        router.url[method](url2);
      };
    };
    this.absorb = () => router.url.replace(urlFromBrowser(router));
    this._pushstateHandler = createStateEventHandler("push");
    this._replacestateHandler = createStateEventHandler("replace");
    this._popstateHandler = () => router.url.pop(urlFromBrowser(router));
  }
  install() {
    this.hooks = [
      history["onPushstate"](this._pushstateHandler),
      history["onReplacestate"](this._replacestateHandler),
      history["onPopstate"](this._popstateHandler)
    ];
    if (!get_store_value(this.router.activeRoute))
      this.absorb();
    else
      this.reflect();
  }
  uninstall() {
    this.hooks.forEach((unreg) => unreg());
    setTimeout(() => this.reflect());
  }
};
function polyfillHistory() {
  const hooks = {
    /** @type {import('hookar').HooksCollection<History['pushState']>} */
    onPushstate: createSequenceHooksCollection(),
    /** @type {import('hookar').HooksCollection<History['replaceState']>} */
    onReplacestate: createSequenceHooksCollection(),
    onPopstate: createSequenceHooksCollection()
  };
  Object.assign(history, hooks);
  const { pushState, replaceState } = history;
  history["pushStateNative"] = pushState;
  history["replaceStateNative"] = replaceState;
  history.pushState = hooks.onPushstate.run;
  history.replaceState = hooks.onReplacestate.run;
  window.addEventListener("popstate", hooks.onPopstate.run);
  return true;
}

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js
var InternalReflector = class extends BaseReflector {
};

// node_modules/@roxi/routify/lib/runtime/plugins/reset/index.js
var parseModuleName = (str) => {
  const matches = str.match(/^(.+?)(\+)?$/);
  const [, name, prepend] = matches;
  return { name, prepend };
};
var handlers = {
  /**
   * @param {Route} route
   * @param {Boolean} bool
   * @param {RouteFragment} fragment
   */
  boolean(route, bool, fragment) {
    const index = fragment.index;
    return handlers.number(route, index, fragment);
  },
  /**
   * @param {Route} route
   * @param {Number} num
   * @param {RouteFragment} fragment
   */
  number(route, num, fragment) {
    const index = fragment.index;
    const start = index - num;
    route.allFragments.splice(start, num);
  },
  /**
   * @param {Route} route
   * @param {string} str
   * @param {RouteFragment} fragment
   */
  string(route, str, fragment) {
    const selfIndex = fragment.index;
    const precedingFragments = route.allFragments.slice(0, selfIndex + 1);
    let nextFragment;
    const { name, prepend } = parseModuleName(str);
    while (precedingFragments.length) {
      nextFragment = precedingFragments.pop();
      const matchingSiblingNode = nextFragment.node.children.find(
        (node2) => node2.meta.moduleName === name
      );
      if (matchingSiblingNode) {
        if (!prepend)
          route.allFragments.splice(0, fragment.index);
        route.allFragments.unshift(route.createFragment(matchingSiblingNode));
        precedingFragments.splice(0);
      }
    }
  }
};
var handleFragment = (route) => (fragment) => {
  const { reset } = fragment.node.meta;
  if (reset)
    handlers[typeof reset](route, reset, fragment);
};
var reset_default = () => {
  return {
    beforeUrlChange: ({ route }) => {
      const fragments = [...route.allFragments];
      fragments.forEach(handleFragment(route));
      return true;
    }
  };
};

// node_modules/@roxi/routify/lib/common/utils.js
var next = (store, wanted, strict) => new Promise((resolve) => {
  let unsub;
  unsub = store.subscribe((value) => {
    if (!unsub)
      return;
    if (typeof wanted === "undefined" || value === wanted || value == wanted && !strict || typeof wanted === "function" && /** @type {function} */
    wanted(value)) {
      resolve(value);
      unsub;
    }
  });
});
var createThrottle = () => {
  const map = /* @__PURE__ */ new Map();
  const throttle2 = async (fn) => {
    const fnStr = fn.toString();
    map.set(fnStr, map.get(fnStr) || { isRunning: false, runAgain: false });
    const s = map.get(fnStr);
    if (s.isRunning)
      s.runAgain = true;
    else {
      s.isRunning = true;
      await fn();
      s.isRunning = false;
      if (s.runAgain) {
        s.runAgain = false;
        await throttle2(fn);
      }
    }
  };
  return throttle2;
};
var throttle = createThrottle();

// node_modules/@roxi/routify/lib/runtime/Router/utils/index.js
var normalizeRouterOptions = (options, config) => {
  config = config || {
    name: "",
    beforeRouterInit: [],
    afterRouterInit: [],
    urlRewrite: [],
    beforeUrlChange: [],
    afterUrlChange: [],
    transformFragments: [],
    onDestroy: []
  };
  const { plugins, ...optionsOnly } = options;
  const optionsGroups = [...plugins || [], optionsOnly];
  optionsGroups.forEach((pluginOptions) => {
    var _a;
    (_a = pluginOptions.plugins) == null ? void 0 : _a.forEach((plugin) => normalizeRouterOptions(plugin, config));
    delete pluginOptions.plugins;
    Object.entries(pluginOptions).forEach(([field, value]) => {
      if (Array.isArray(config[field]))
        config[field].push(...[value].flat().filter(Boolean));
      else
        config[field] = value || config[field];
    });
  });
  return config;
};

// node_modules/@roxi/routify/lib/runtime/Router/Router.js
var stripNullFields = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
var defaultPlugins = [reset_default()];
var Router = class _Router {
  /**
   * @param {Partial<RoutifyRuntimeOptions>} input
   */
  constructor(input) {
    /** @type { RouteStore } */
    __publicField(this, "pendingRoute", getable(null));
    /** @type { RouteStore } */
    __publicField(this, "activeRoute", getable(null));
    __publicField(this, "_urlReflector", null);
    /** @type {UrlRewrite[]} */
    __publicField(this, "urlRewrites", []);
    /** @type { import('hookar').HooksCollection<RouterInitCallback> } */
    __publicField(this, "beforeRouterInit", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<RouterInitCallback> } */
    __publicField(this, "afterRouterInit", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<BeforeUrlChangeCallback> } */
    __publicField(this, "beforeUrlChange", createGuardsCollection());
    /** @type { import('hookar').HooksCollection<AfterUrlChangeCallback> } */
    __publicField(this, "afterUrlChange", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<TransformFragmentsCallback> } */
    __publicField(this, "transformFragments", createPipelineCollection());
    /** @type { import('hookar').HooksCollection<OnDestroyRouterCallback> } */
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "parentElem", null);
    /** @type {QueryHandler} */
    __publicField(this, "queryHandler", {
      parse: (search, route) => fromEntries(new URLSearchParams(search)),
      stringify: (params2, route) => {
        const query = new URLSearchParams(params2).toString();
        return query ? `?${query}` : "";
      }
    });
    /** @type {ClickHandler} */
    __publicField(this, "clickHandler", {});
    __publicField(this, "url", {
      internal: () => this.url.getPending() || this.url.getActive(),
      external: () => this.getExternalUrl(),
      getActive: () => {
        var _a;
        return (_a = get_store_value(this.activeRoute)) == null ? void 0 : _a.url;
      },
      getPending: () => {
        var _a;
        return (_a = get_store_value(this.pendingRoute)) == null ? void 0 : _a.url;
      },
      toString: () => this.url.internal(),
      set: this._setUrl.bind(this),
      push: (url2, state = {}) => this._setUrl(url2, "pushState", false, state),
      replace: (url2, state = {}) => this._setUrl(url2, "replaceState", false, state),
      pop: (url2, state = {}) => this._setUrl(url2, "popState", false, state)
    });
    /**
     * function that resolves after the active route has changed
     * @returns {Promise<Route>} */
    __publicField(this, "ready", async () => !this.pendingRoute.get() && this.activeRoute.get() || next(this.activeRoute, (x) => !!x));
    /** @type {Route[]} */
    __publicField(this, "history", []);
    /** @param {HTMLElement} elem */
    __publicField(this, "setParentElem", (elem) => {
      this.parentElem = elem;
    });
    /**
     * converts a URL or Routify's internal URL to an external URL (for the browser)
     * @param {string=} url
     * @returns
     */
    __publicField(this, "getExternalUrl", (url2) => {
      const result = this.urlRewrites.reduce(
        (_url, rewrite) => rewrite.toExternal(_url, { router: this }),
        url2 || this.url.internal()
      );
      return result;
    });
    /**
     * converts an external URL (from the browser) to an internal URL
     * @param {string} url
     * @returns
     */
    __publicField(this, "getInternalUrl", (url2) => this.urlRewrites.reduce(
      (_url, rewrite) => rewrite.toInternal(_url, { router: this }),
      url2
    ));
    const { subscribe: subscribe2, set } = writable(this);
    this.subscribe = subscribe2;
    this.triggerStore = () => set(this);
    const oldRouter = appInstance.routers.find((r) => r.name == (input.name || ""));
    if (oldRouter)
      return oldRouter;
    else {
      input.plugins = [...input.plugins || [], ...defaultPlugins].filter(Boolean);
      this.init(input);
      this.params = derived(this.activeRoute, ($activeRoute) => $activeRoute.params);
      this.afterUrlChange(() => setTimeout(() => this._urlReflector.reflect()));
      this.activeRoute.get = () => get_store_value(this.activeRoute);
      this.pendingRoute.get = () => get_store_value(this.pendingRoute);
    }
  }
  /**
   * @param {Partial<RoutifyRuntimeOptions>} input
   */
  init(input) {
    const firstInit = !this.options;
    input = stripNullFields(input);
    this.options = normalizeRouterOptions({ ...this.options, ...input });
    let {
      instance: instance8,
      rootNode,
      name,
      routes,
      urlRewrite,
      urlReflector,
      url: url2,
      passthrough,
      beforeUrlChange: beforeUrlChange2,
      afterUrlChange: afterUrlChange2,
      transformFragments,
      onDestroy: onDestroy2,
      beforeRouterInit,
      afterRouterInit,
      queryHandler,
      clickHandler
    } = this.options;
    if (queryHandler)
      this.queryHandler = queryHandler;
    if (clickHandler)
      this.clickHandler = clickHandler;
    beforeUrlChange2.forEach(this.beforeUrlChange);
    transformFragments.forEach(this.transformFragments);
    afterUrlChange2.forEach(this.afterUrlChange);
    onDestroy2.forEach(this.onDestroy);
    beforeRouterInit.forEach(this.beforeRouterInit);
    afterRouterInit.forEach(this.afterRouterInit);
    this.beforeRouterInit.run({ router: this, firstInit });
    const parentCmpCtx = getContextMaybe("routify-fragment-context");
    this.instance = instance8 || this.instance || (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router.instance) || appInstance.instances[0] || new RoutifyRuntime({});
    this.name = name;
    this.urlRewrites = urlRewrite;
    this.log = this.log || this.instance.log.createChild(this.name || "[unnamed instance]");
    if (passthrough && !(passthrough instanceof _Router))
      passthrough = (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router) || passthrough;
    this.passthrough = passthrough || this.passthrough;
    appInstance.instances.forEach((inst) => {
      const index = inst.routers.indexOf(this);
      if (index !== -1)
        inst.routers.splice(index, 1);
    });
    this.instance.routers.push(this);
    if (routes && !this.rootNode)
      this.importRoutes(routes);
    this.parentCmpCtx = parentCmpCtx;
    this.rootNode = rootNode || this.rootNode || this.instance.rootNodes.default;
    this.log.debug("initiated router");
    if (this.url.getActive()) {
      this.log.debug("router was created with activeUrl");
      this._setUrl(this.url.getActive(), "pushState", true);
    }
    const shouldInstallUrlReflector = !this.urlReflector || urlReflector && !(this.urlReflector instanceof urlReflector);
    if (shouldInstallUrlReflector) {
      urlReflector = urlReflector || (typeof window != "undefined" ? AddressReflector : InternalReflector);
      this.setUrlReflector(urlReflector);
    }
    if (url2)
      this.url.replace(url2);
    this.triggerStore();
    this.afterRouterInit.run({ router: this, firstInit });
  }
  importRoutes(routes) {
    this.rootNode = this.instance.createNode().importTree(routes);
    this.instance.rootNodes[routes.rootName || "unnamed"] = this.rootNode;
  }
  /**
   *
   * @param {string} url
   * @param {UrlState} mode pushState, replaceState or popState
   * @param {boolean} [isInternal=false] if the URL is already internal, skip rewrite.toInternal
   * @param {Object=} state a state to attach to the route
   * @returns {Promise<true|false>}
   */
  async _setUrl(url2, mode, isInternal, state = {}) {
    if (!isInternal)
      url2 = this.getInternalUrl(url2);
    url2 = url2 || "/";
    url2 = url2.replace(/(.+)\/+([#?]|$)/, "$1$2");
    const { activeRoute: activeRoute2, pendingRoute: pendingRoute2 } = this;
    const { debug, groupCollapsed, trace, groupEnd } = this.log;
    if (this.log.level >= 4) {
      const info = {
        url: url2,
        mode,
        prev: this.url.internal(),
        browserOld: urlFromAddress(),
        state
      };
      [groupCollapsed("set url", info), trace(), groupEnd()];
    }
    if (!url2.startsWith("/"))
      url2 = url2.replace(new URL(url2).origin, "");
    const route = new Route(this, url2, mode, state);
    const currentRoute = pendingRoute2.get() || activeRoute2.get();
    if (identicalRoutes(currentRoute, route)) {
      debug("current route is identical - skip", currentRoute, route);
      return true;
    }
    route.log.debug("set pending route", route);
    pendingRoute2.set(route);
    await route.loadRoute();
    return true;
  }
  destroy() {
    this.log.debug(`destroying router`);
    this.instance.routers = this.instance.routers.filter((router) => router !== this);
    this.onDestroy.run({ router: this });
  }
  /** @type {BaseReflector} */
  get urlReflector() {
    return this._urlReflector;
  }
  /** @param {typeof BaseReflector} UrlReflector */
  setUrlReflector(UrlReflector) {
    var _a;
    (_a = this._urlReflector) == null ? void 0 : _a.uninstall();
    this._urlReflector = new UrlReflector(this);
    this._urlReflector.install();
    this.triggerStore();
  }
};
var createRouter = (options) => new Router(options);

// node_modules/@roxi/routify/lib/runtime/renderer/DecoratorWrapper.svelte
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*decorator*/
    ctx[2].component
  );
  function switch_props(ctx2) {
    return {
      props: {
        context: (
          /*context*/
          ctx2[1]
        ),
        isRoot: (
          /*isRoot*/
          ctx2[0]
        ),
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*context*/
      2)
        switch_instance_changes.context = /*context*/
        ctx2[1];
      if (dirty & /*isRoot*/
      1)
        switch_instance_changes.isRoot = /*isRoot*/
        ctx2[0];
      if (dirty & /*$$scope, restOfDecorators, context*/
      74) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & /*decorator*/
      4 && switch_value !== (switch_value = /*decorator*/
      ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:0) {#if decorator}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(19:8) <svelte:self decorators={restOfDecorators} {context} isRoot={false}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper({
    props: {
      decorators: (
        /*restOfDecorators*/
        ctx[3]
      ),
      context: (
        /*context*/
        ctx[1]
      ),
      isRoot: false,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & /*restOfDecorators*/
      8)
        decoratorwrapper_changes.decorators = /*restOfDecorators*/
        ctx2[3];
      if (dirty & /*context*/
      2)
        decoratorwrapper_changes.context = /*context*/
        ctx2[1];
      if (dirty & /*$$scope*/
      64) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(18:4) <svelte:component this={decorator.component} {context} {isRoot}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*decorator*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DecoratorWrapper", slots, ["default"]);
  let { decorators = null } = $$props;
  let { isRoot = true } = $$props;
  let { context: context2 } = $$props;
  decorators = decorators || context2.decorators;
  let [decorator, ...restOfDecorators] = [...decorators];
  while (decorator && !(decorator == null ? void 0 : decorator.shouldRender({ context: context2, isRoot, decorators })))
    [decorator, ...restOfDecorators] = [...restOfDecorators];
  if (isRoot)
    onDestroy(() => context2.onDestroy.run());
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<DecoratorWrapper> was created without expected prop 'context'");
    }
  });
  const writable_props = ["decorators", "isRoot", "context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DecoratorWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    decorators,
    isRoot,
    context: context2,
    decorator,
    restOfDecorators
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("decorator" in $$props2)
      $$invalidate(2, decorator = $$props2.decorator);
    if ("restOfDecorators" in $$props2)
      $$invalidate(3, restOfDecorators = $$props2.restOfDecorators);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isRoot, context2, decorator, restOfDecorators, decorators, slots, $$scope];
}
var DecoratorWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { decorators: 4, isRoot: 0, context: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DecoratorWrapper",
      options,
      id: create_fragment2.name
    });
  }
  get decorators() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorators(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isRoot(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DecoratorWrapper_default = DecoratorWrapper;

// node_modules/@roxi/routify/lib/runtime/decorators/Noop.svelte
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noop", slots, ["default"]);
  let { context: context2 = null } = $$props;
  let { Parent = null } = $$props;
  context2;
  Parent;
  const writable_props = ["context", "Parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noop> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ context: context2, Parent });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [context2, Parent, $$scope, slots];
}
var Noop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { context: 0, Parent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noop",
      options,
      id: create_fragment3.name
    });
  }
  get context() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Parent() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Parent(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Noop_default = Noop;

// node_modules/@roxi/routify/lib/runtime/decorators/AnchorDecorator.svelte
var { Error: Error_1 } = globals;
var file = "node_modules\\@roxi\\routify\\lib\\runtime\\decorators\\AnchorDecorator.svelte";
function create_else_block3(ctx) {
  let t;
  let current;
  let if_block = !/*mounted*/
  ctx[2] && create_if_block_2(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*mounted*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(42:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t;
  let current;
  let div_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 39, 4, 1233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[8](div);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[8](null);
      if (detaching)
        detach_dev(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(39:32) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 35, 4, 1128);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      8 && /*$$restProps*/
      ctx2[3]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(35:0) {#if location === 'wrapper'}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let div_levels = [
    { "data-routify-anchor-locator": "" },
    { class: "anchor" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-routify-anchor-locator": true,
        class: true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 43, 8, 1323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[9](div);
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-locator": "" },
        { class: "anchor" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(43:4) {#if !mounted}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_1, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*location*/
      ctx2[0] === "wrapper"
    )
      return 0;
    if (
      /*location*/
      ctx2[0] === "header"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["location", "onMount"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnchorDecorator", slots, ["default"]);
  let { location: location2 } = $$props;
  let { onMount: onMount2 = (x) => x } = $$props;
  let elem;
  let mounted = false;
  const nextValidSibling = (elem2) => {
    const next2 = (
      /** @type {HTMLElement}*/
      elem2.nextElementSibling
    );
    return next2 && "routifyAnchorLocator" in next2.dataset ? nextValidSibling(next2) : next2;
  };
  onMount(async () => {
    if (location2 === "wrapper")
      onMount2(elem);
    else if (location2 === "parent")
      onMount2(elem.parentNode);
    else if (location2 === "header")
      onMount2(elem.parentElement, elem);
    else if (location2 === "firstChild") {
      const nextSib = nextValidSibling(elem);
      onMount2(elem.parentElement, nextSib);
    } else
      throw new Error(`Incorrect location provided. Got ${location2}`);
    $$invalidate(2, mounted = true);
  });
  $$self.$$.on_mount.push(function() {
    if (location2 === void 0 && !("location" in $$props || $$self.$$.bound[$$self.$$.props["location"]])) {
      console.warn("<AnchorDecorator> was created without expected prop 'location'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("location" in $$new_props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$new_props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _onMount: onMount,
    location: location2,
    onMount: onMount2,
    elem,
    mounted,
    nextValidSibling
  });
  $$self.$inject_state = ($$new_props) => {
    if ("location" in $$props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("elem" in $$props)
      $$invalidate(1, elem = $$new_props.elem);
    if ("mounted" in $$props)
      $$invalidate(2, mounted = $$new_props.mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    location2,
    elem,
    mounted,
    $$restProps,
    onMount2,
    $$scope,
    slots,
    div_binding,
    div_binding_1,
    div_binding_2
  ];
}
var AnchorDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { location: 0, onMount: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnchorDecorator",
      options,
      id: create_fragment4.name
    });
  }
  get location() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set location(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMount() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMount(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnchorDecorator_default = AnchorDecorator;

// node_modules/@roxi/routify/lib/runtime/renderer/RenderFragment.svelte
function create_if_block4(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      location: (
        /*context*/
        ctx[0].anchorLocation
      ),
      onMount: (
        /*initialize*/
        ctx[9]
      ),
      context: (
        /*context*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchordecorator_changes = {};
      if (dirty & /*context*/
      1)
        anchordecorator_changes.location = /*context*/
        ctx2[0].anchorLocation;
      if (dirty & /*context*/
      1)
        anchordecorator_changes.context = /*context*/
        ctx2[0];
      if (dirty & /*$$scope, context, NodeComponent, compProps, routifyContext, props, $childFragments*/
      524407) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(43:0) {#if $isVisible && !isAnonFn(NodeComponent)}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let compose;
  let current;
  compose = new ComposeFragments_default({
    props: {
      options: {
        multi: (
          /*multi*/
          ctx[14]
        ),
        decorator: (
          /*decorator*/
          ctx[15]
        ),
        props: (
          /*props*/
          ctx[1]
        ),
        options: (
          /*options*/
          ctx[17]
        ),
        scrollBoundary: (
          /*scrollBoundary*/
          ctx[18]
        ),
        anchor: (
          /*anchor*/
          ctx[16] || /*context*/
          ctx[0].anchorLocation
        )
      },
      context: (
        /*context*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(compose.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(compose.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(compose, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const compose_changes = {};
      if (dirty & /*multi, decorator, props, options, scrollBoundary, anchor, context*/
      507907)
        compose_changes.options = {
          multi: (
            /*multi*/
            ctx2[14]
          ),
          decorator: (
            /*decorator*/
            ctx2[15]
          ),
          props: (
            /*props*/
            ctx2[1]
          ),
          options: (
            /*options*/
            ctx2[17]
          ),
          scrollBoundary: (
            /*scrollBoundary*/
            ctx2[18]
          ),
          anchor: (
            /*anchor*/
            ctx2[16] || /*context*/
            ctx2[0].anchorLocation
          )
        };
      if (dirty & /*context*/
      1)
        compose_changes.context = /*context*/
        ctx2[0];
      compose.$set(compose_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(compose.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(compose.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(compose, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(60:17) {#if $childFragments.length || (multi && !multi?.single)}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = (
    /*$childFragments*/
    (ctx[6].length || /*multi*/
    ctx[14] && !/*multi*/
    ((_a = ctx[14]) == null ? void 0 : _a.single)) && create_if_block_12(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (
        /*$childFragments*/
        ctx2[6].length || /*multi*/
        ctx2[14] && !/*multi*/
        ((_a2 = ctx2[14]) == null ? void 0 : _a2.single)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$childFragments, multi*/
          16448) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(50:12) <svelte:component                 this={NodeComponent}                 {...compProps}                 context={routifyContext}                 let:props                 let:multi                 let:decorator                 let:anchor                 let:options                 let:scrollBoundary                 >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*compProps*/
    ctx[5],
    { context: (
      /*routifyContext*/
      ctx[4]
    ) }
  ];
  var switch_value = (
    /*NodeComponent*/
    ctx[2]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: {
        default: [
          create_default_slot_2,
          ({ props, multi, decorator, anchor, options, scrollBoundary }) => ({
            1: props,
            14: multi,
            15: decorator,
            16: anchor,
            17: options,
            18: scrollBoundary
          }),
          ({ props, multi, decorator, anchor, options, scrollBoundary }) => (props ? 2 : 0) | (multi ? 16384 : 0) | (decorator ? 32768 : 0) | (anchor ? 65536 : 0) | (options ? 131072 : 0) | (scrollBoundary ? 262144 : 0)
        ]
      },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & /*compProps, routifyContext*/
      48 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*compProps*/
        32 && get_spread_object(
          /*compProps*/
          ctx2[5]
        ),
        dirty & /*routifyContext*/
        16 && { context: (
          /*routifyContext*/
          ctx2[4]
        ) }
      ]) : {};
      if (dirty & /*$$scope, multi, decorator, props, options, scrollBoundary, anchor, context, $childFragments*/
      1032259) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & /*NodeComponent*/
      4 && switch_value !== (switch_value = /*NodeComponent*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(48:8) <DecoratorWrapper {context}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper_default({
    props: {
      context: (
        /*context*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & /*context*/
      1)
        decoratorwrapper_changes.context = /*context*/
        ctx2[0];
      if (dirty & /*$$scope, NodeComponent, compProps, routifyContext, props, context, $childFragments*/
      524407) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(45:4) <AnchorDecorator location={context.anchorLocation} onMount={initialize} {context}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let show_if = (
    /*$isVisible*/
    ctx[3] && !isAnonFn(
      /*NodeComponent*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block4(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isVisible, NodeComponent*/
      12)
        show_if = /*$isVisible*/
        ctx2[3] && !isAnonFn(
          /*NodeComponent*/
          ctx2[2]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isVisible, NodeComponent*/
          12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  var _a;
  let params2;
  let load;
  let route;
  let compProps;
  let routifyContext;
  let $isVisible;
  let $childFragments;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderFragment", slots, []);
  let { context: context2 } = $$props;
  let { props } = $$props;
  const { isVisible, childFragments } = context2;
  validate_store(isVisible, "isVisible");
  component_subscribe($$self, isVisible, (value) => $$invalidate(3, $isVisible = value));
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(6, $childFragments = value));
  let NodeComponent = ((_a = context2.node.module) == null ? void 0 : _a.default) || context2.node.asyncModule || Noop_default;
  setContext("routify-fragment-context", context2);
  const updateRenderContext = (elem, newMeta) => {
    var _a2;
    elem["__routify_meta"] = {
      ...elem["__routify_meta"],
      renderContext: {
        ...(_a2 = elem["__routify_meta"]) == null ? void 0 : _a2.renderContext,
        ...newMeta
      }
    };
    return elem;
  };
  const initialize = (parent, anchor) => {
    context2.elem.set({ anchor, parent });
    parent = updateRenderContext(parent, { parent: context2 });
    if (anchor)
      anchor = updateRenderContext(anchor, { anchor: context2 });
  };
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<RenderFragment> was created without expected prop 'context'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<RenderFragment> was created without expected prop 'props'");
    }
  });
  const writable_props = ["context", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RenderFragment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    Compose: ComposeFragments_default,
    setContext,
    DecoratorWrapper: DecoratorWrapper_default,
    Noop: Noop_default,
    AnchorDecorator: AnchorDecorator_default,
    isAnonFn,
    context: context2,
    props,
    isVisible,
    childFragments,
    NodeComponent,
    updateRenderContext,
    initialize,
    route,
    load,
    routifyContext,
    params: params2,
    compProps,
    $isVisible,
    $childFragments
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("NodeComponent" in $$props2)
      $$invalidate(2, NodeComponent = $$props2.NodeComponent);
    if ("route" in $$props2)
      $$invalidate(10, route = $$props2.route);
    if ("load" in $$props2)
      $$invalidate(11, load = $$props2.load);
    if ("routifyContext" in $$props2)
      $$invalidate(4, routifyContext = $$props2.routifyContext);
    if ("params" in $$props2)
      $$invalidate(12, params2 = $$props2.params);
    if ("compProps" in $$props2)
      $$invalidate(5, compProps = $$props2.compProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*NodeComponent, $isVisible, context*/
    13) {
      $:
        if (isAnonFn(NodeComponent) && $isVisible)
          context2.node.loadModule().then((r) => $$invalidate(2, NodeComponent = r.default));
    }
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        $$invalidate(12, { params: params2, load, route } = context2.fragment, params2, ($$invalidate(11, load), $$invalidate(0, context2)), ($$invalidate(10, route), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & /*params, load, props*/
    6146) {
      $:
        $$invalidate(5, compProps = { ...params2, ...load == null ? void 0 : load.props, ...props });
    }
    if ($$self.$$.dirty & /*context, load, route*/
    3073) {
      $:
        $$invalidate(4, routifyContext = { ...context2, load, route });
    }
  };
  return [
    context2,
    props,
    NodeComponent,
    $isVisible,
    routifyContext,
    compProps,
    $childFragments,
    isVisible,
    childFragments,
    initialize,
    route,
    load,
    params2
  ];
}
var RenderFragment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { context: 0, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderFragment",
      options,
      id: create_fragment5.name
    });
  }
  get context() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderFragment_default = RenderFragment;

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeMulti.js
var nodeIsPage = (node2) => {
  var _a;
  return !node2.meta.fallback && !node2.name.startsWith("_") && ((_a = node2.meta) == null ? void 0 : _a.order) !== false;
};
var getChildren = (refNode, parentContext) => {
  const parentNode = (parentContext == null ? void 0 : parentContext.node) || refNode.parent;
  const matches = parentNode ? parentNode.children.filter((node2) => node2 === refNode || nodeIsPage(node2)) : [refNode];
  return matches.length ? matches : [refNode];
};
var coerceStringToNode = (nodeOrString, refNode) => typeof nodeOrString === "string" ? refNode.traverse(nodeOrString) : nodeOrString;
var coercePagesToNodes = (pagesInput, refNode, parentContext) => {
  const pageInputs = Array.isArray(pagesInput) ? pagesInput : getChildren(refNode, parentContext);
  return pageInputs.map((page) => coerceStringToNode(page, refNode));
};
var convertToObj = (multiInput) => multiInput instanceof Object ? !Array.isArray(multiInput) ? multiInput : { pages: multiInput } : {};
var normalizeMulti = (multiInput, refNode, parentContext) => {
  const multi = convertToObj(multiInput);
  multi.single = multi.single || !multiInput;
  multi.pages = coercePagesToNodes(multi.pages, refNode, parentContext);
  multi.renderInactive = multi.renderInactive || "browser";
  return multi;
};

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeDecorator.js
var decoratorDefaults = { recursive: true, shouldRender: () => true };
var normalizeDecorator = (decorator) => {
  if ("component" in decorator)
    return { ...decoratorDefaults, ...decorator };
  else
    return { ...decoratorDefaults, component: decorator };
};

// node_modules/@roxi/routify/lib/runtime/renderer/ComposeFragments.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = (
    /*childContexts*/
    ctx[1]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*context*/
    ctx2[0].node.id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*childContexts, props*/
      34) {
        each_value = /*childContexts*/
        ctx2[1];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(143:0) {#if !wait}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let renderfragment;
  let current;
  renderfragment = new RenderFragment_default({
    props: {
      context: (
        /*context*/
        ctx[0]
      ),
      props: (
        /*props*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderfragment.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderfragment.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderfragment_changes = {};
      if (dirty & /*childContexts*/
      2)
        renderfragment_changes.context = /*context*/
        ctx[0];
      renderfragment.$set(renderfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(renderfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(144:4) {#each childContexts as context (context.node.id)}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*wait*/
  ctx[2] && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*wait*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*wait*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  var _a;
  let $childFragments;
  let $isActive;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposeFragments", slots, []);
  let { context: context2 = null } = $$props;
  let { options } = $$props;
  const environment = typeof window !== "undefined" ? "browser" : "ssr";
  let activeContext;
  const { childFragments, isActive: isActive2, route } = context2;
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(7, $childFragments = value));
  validate_store(isActive2, "isActive");
  component_subscribe($$self, isActive2, (value) => $$invalidate(8, $isActive = value));
  const { multi: multiInput, decorator, props, anchor: anchorLocation, options: _options, scrollBoundary = (elem) => elem.parentElement } = options;
  const getChildIndex = (node2) => node2.children.find((node3) => node3.name === "index");
  const recursiveDecorators = context2.decorators.filter((deco) => deco.recursive);
  const newDecorators = pushToOrReplace(recursiveDecorators, decorator).filter(Boolean).map(normalizeDecorator);
  const folderDecorator = (_a = context2 == null ? void 0 : context2.node) == null ? void 0 : _a.children.find((node2) => node2.name === "_decorator");
  const addFolderDecorator = (decorators, folderDecorator2) => {
    const options2 = folderDecorator2.module.options || {};
    decorators.push({
      component: folderDecorator2.module.default,
      recursive: options2.recursive ?? folderDecorator2.meta.recursive ?? true,
      shouldRender: options2.shouldRender ?? (() => true)
    });
  };
  let wait = false;
  if (folderDecorator) {
    if (folderDecorator.module)
      addFolderDecorator(newDecorators, folderDecorator);
    else {
      wait = true;
      folderDecorator.loadModule().then(() => {
        addFolderDecorator(newDecorators, folderDecorator);
        $$invalidate(2, wait = false);
      });
    }
  }
  const buildChildContexts = () => {
    var _a2;
    const multi = normalizeMulti(multiInput, (_a2 = $childFragments[0]) == null ? void 0 : _a2.node, context2);
    return multi.pages.map((node2) => {
      var _a3, _b;
      return {
        anchorLocation: anchorLocation || "parent",
        childFragments: writable(getChildIndex(node2) ? [new RouteFragment(route, getChildIndex(node2))] : []),
        node: node2,
        fragment: new RouteFragment(route, node2, null, {}),
        isActive: writable(false),
        isVisible: writable(false),
        elem: writable(null),
        router: ((_b = (_a3 = $childFragments[0]) == null ? void 0 : _a3.route) == null ? void 0 : _b.router) || context2.router,
        route: null,
        parentContext: context2,
        onDestroy: createSequenceHooksCollection(),
        decorators: newDecorators,
        options: _options || {},
        scrollBoundary,
        multi,
        single: writable(multi.single)
      };
    });
  };
  let childContexts = buildChildContexts();
  const handlePageChange = (fragments) => {
    const [fragment, ...childFragments2] = [...fragments];
    activeContext = childContexts.find((s) => s.node === (fragment == null ? void 0 : fragment.node));
    if (!activeContext) {
      $$invalidate(1, childContexts = buildChildContexts());
      return handlePageChange(fragments);
    }
    activeContext.fragment = fragment;
    activeContext.childFragments.set(childFragments2);
    activeContext.route = fragments[0].route;
    $$invalidate(1, childContexts);
  };
  const setVisibility = (childContexts2) => {
    childContexts2.forEach((context3) => {
      const notExcludedCtx = (context4) => {
        var _a2, _b;
        return !((_b = (_a2 = context4 == null ? void 0 : context4.node) == null ? void 0 : _a2.meta.multi) == null ? void 0 : _b.exclude);
      };
      const isPartOfPage = () => {
        var _a2;
        return (
          // if this isn't part of the active route, activeContext is undefined
          !get_store_value(activeContext == null ? void 0 : activeContext.single) && !get_store_value(context3.single) && [context3, activeContext].every(notExcludedCtx) && ["always", environment].includes((_a2 = context3.multi) == null ? void 0 : _a2.renderInactive)
        );
      };
      const isActive3 = context3 === activeContext;
      const wasActive = get_store_value(context3.isActive);
      if (wasActive != isActive3)
        context3.isActive.set(isActive3);
      const isVisible = isActive3 || isPartOfPage();
      const wasVisible = get_store_value(context3.isVisible);
      if (wasVisible != isVisible)
        context3.isVisible.set(isVisible);
    });
  };
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ComposeFragments> was created without expected prop 'options'");
    }
  });
  const writable_props = ["context", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ComposeFragments> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    createSequenceHooksCollection,
    get: get_store_value,
    writable,
    RouteFragment,
    pushToOrReplace,
    RenderFragment: RenderFragment_default,
    normalizeDecorator,
    normalizeMulti,
    context: context2,
    options,
    environment,
    activeContext,
    childFragments,
    isActive: isActive2,
    route,
    multiInput,
    decorator,
    props,
    anchorLocation,
    _options,
    scrollBoundary,
    getChildIndex,
    recursiveDecorators,
    newDecorators,
    folderDecorator,
    addFolderDecorator,
    wait,
    buildChildContexts,
    childContexts,
    handlePageChange,
    setVisibility,
    $childFragments,
    $isActive
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("activeContext" in $$props2)
      activeContext = $$props2.activeContext;
    if ("wait" in $$props2)
      $$invalidate(2, wait = $$props2.wait);
    if ("childContexts" in $$props2)
      $$invalidate(1, childContexts = $$props2.childContexts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$isActive, childContexts*/
    258) {
      $:
        if (!$isActive)
          childContexts.forEach((cc) => cc.isActive.set(false));
    }
    if ($$self.$$.dirty & /*$childFragments*/
    128) {
      $:
        $childFragments.length && handlePageChange($childFragments);
    }
    if ($$self.$$.dirty & /*childContexts*/
    2) {
      $:
        setVisibility(childContexts);
    }
  };
  return [
    context2,
    childContexts,
    wait,
    childFragments,
    isActive2,
    props,
    options,
    $childFragments,
    $isActive
  ];
}
var ComposeFragments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { context: 0, options: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposeFragments",
      options,
      id: create_fragment6.name
    });
  }
  get context() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposeFragments_default = ComposeFragments;

// node_modules/@roxi/routify/lib/runtime/helpers/scroll.js
var persistentScopedScrollIntoView = (_elem, _boundary, options, timeout) => {
  let elem = resolveIfAnonFn2(_elem, [_boundary]);
  const boundary = resolveIfAnonFn2(_boundary, [elem]);
  options = options || {};
  options.behavior = "auto";
  scopedScrollIntoView(elem, boundary);
  const observer = new MutationObserver((mo) => {
    if (mo.length > 1 || mo[0].addedNodes.length || mo[0].removedNodes.length) {
      scopedScrollIntoView(elem, boundary);
    }
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true
  });
  const stopScroll = () => observer.disconnect();
  if (timeout) {
    return new Promise(
      (resolve) => setTimeout(() => {
        stopScroll();
        resolve();
      }, timeout)
    );
  } else {
    timeout;
    return stopScroll;
  }
};
var getScrollBoundaries = () => [
  ...document.querySelectorAll('[data-routify-scroll="lock"]'),
  ...appInstance.routers.filter((router) => router.parentCmpCtx).map((router) => router.parentElem)
];
var getMulti = (elem) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  if (!elem)
    return false;
  if ((_a = elem["__routify_meta"]) == null ? void 0 : _a.router)
    return false;
  if ((_d = (_c = (_b = elem["__routify_meta"]) == null ? void 0 : _b.renderContext) == null ? void 0 : _c.anchor) == null ? void 0 : _d.single)
    return !get_store_value((_g = (_f = (_e = elem["__routify_meta"]) == null ? void 0 : _e.renderContext) == null ? void 0 : _f.anchor) == null ? void 0 : _g.single);
  if ((_j = (_i = (_h = elem["__routify_meta"]) == null ? void 0 : _h.renderContext) == null ? void 0 : _i.parent) == null ? void 0 : _j.single)
    return !get_store_value((_m = (_l = (_k = elem["__routify_meta"]) == null ? void 0 : _k.renderContext) == null ? void 0 : _l.parent) == null ? void 0 : _m.single);
  else
    return getMulti(elem.parentElement);
};
var resolveIfAnonFn2 = (subject, params2) => {
  const isAnonFn2 = typeof subject === "function" && !subject["prototype"];
  return isAnonFn2 ? (
    /** @type {any} */
    subject(...params2)
  ) : subject;
};
var scopedScrollIntoView = async (_elem, _boundary) => {
  let elem = await resolveIfAnonFn2(_elem, [_boundary]);
  const boundary = await resolveIfAnonFn2(_boundary, [elem]);
  let parent = elem.parentElement;
  while ((parent == null ? void 0 : parent.scrollTo) && parent.dataset["routifyScroll"] !== "lock" && parent !== (boundary == null ? void 0 : boundary.parentElement)) {
    const scrollToPos = getMulti(elem) || elem["routify-hash-nav"];
    if (!scrollToPos) {
      parent.scrollTo(0, 0);
    } else {
      const targetRect = elem.getBoundingClientRect();
      const parentRect = parent.getBoundingClientRect();
      const scrollTop = parent.parentElement ? parent.scrollTop : 0;
      const scrollLeft = parent.parentElement ? parent.scrollLeft : 0;
      const top = scrollTop + targetRect.top - parentRect.top;
      const left = scrollLeft + targetRect.left - parentRect.left;
      parent.scrollTo({ top, left });
    }
    if (!scrollToPos)
      elem = parent;
    parent = parent.parentElement;
  }
};
var scrollToContext = async (context2) => {
  const { anchor, parent } = await waitFor(context2.elem, Boolean);
  const scrollTarget = anchor || parent;
  let scrollBoundary = await context2.scrollBoundary;
  scopedScrollIntoView(scrollTarget, scrollBoundary);
};

// node_modules/@roxi/routify/lib/runtime/decorators/ScrollDecorator.svelte
function create_fragment7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var hashScroll = (route) => {
  setTimeout(
    async () => {
      var _a;
      const hashElem = (_a = globalThis.document) == null ? void 0 : _a.getElementById(route == null ? void 0 : route.hash);
      hashElem["routify-hash-nav"] = "true";
      await persistentScopedScrollIntoView(hashElem, null, {}, 500);
      delete hashElem["routify-hash-nav"];
    },
    0
  );
};
function instance7($$self, $$props, $$invalidate) {
  let route;
  let isActive2;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScrollDecorator", slots, ["default"]);
  let { context: context2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'context'");
    }
  });
  const writable_props = ["context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScrollDecorator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    scrollToContext,
    persistentScopedScrollIntoView,
    hashScroll,
    context: context2,
    route,
    isActive: isActive2
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("route" in $$props2)
      $$invalidate(1, route = $$props2.route);
    if ("isActive" in $$props2)
      $$invalidate(2, isActive2 = $$props2.isActive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        $$invalidate(1, { route, isActive: isActive2 } = context2, route, ($$invalidate(2, isActive2), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & /*route, isActive, context*/
    7) {
      $:
        if (route == null ? void 0 : route.hash)
          hashScroll(route);
        else if (get_store_value(isActive2) && !(route == null ? void 0 : route.state.dontScroll))
          scrollToContext(context2);
    }
  };
  return [context2, route, isActive2, $$scope, slots];
}
var ScrollDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { context: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollDecorator",
      options,
      id: create_fragment7.name
    });
  }
  get context() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScrollDecorator_default = ScrollDecorator;

// node_modules/@roxi/routify/lib/runtime/Router/Router.svelte
function create_if_block6(ctx) {
  let component;
  let current;
  component = new ComposeFragments_default({
    props: {
      context: (
        /*context*/
        ctx[4]
      ),
      options: { decorator: (
        /*decorator*/
        ctx[0]
      ) }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = {};
      if (dirty & /*decorator*/
      1)
        component_changes.options = { decorator: (
          /*decorator*/
          ctx2[0]
        ) };
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(113:4) {#if $activeRoute}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$activeRoute*/
    ctx[2] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$activeRoute*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$activeRoute*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(112:0) <AnchorDecorator onMount={initialize} style=\\"display: contents\\" location={anchor}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      onMount: (
        /*initialize*/
        ctx[5]
      ),
      style: "display: contents",
      location: (
        /*anchor*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const anchordecorator_changes = {};
      if (dirty & /*anchor*/
      2)
        anchordecorator_changes.location = /*anchor*/
        ctx2[1];
      if (dirty & /*$$scope, decorator, $activeRoute*/
      67108869) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let activeRoute2;
  let $activeRoute, $$unsubscribe_activeRoute = noop, $$subscribe_activeRoute = () => ($$unsubscribe_activeRoute(), $$unsubscribe_activeRoute = subscribe(activeRoute2, ($$value) => $$invalidate(2, $activeRoute = $$value)), activeRoute2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeRoute());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { router = null } = $$props;
  let { routes = null } = $$props;
  let { decorator = null } = $$props;
  let { urlReflector = null } = $$props;
  let { instance: instance8 = null } = $$props;
  let { urlRewrite = null } = $$props;
  let { url: url2 = null } = $$props;
  let { name = null } = $$props;
  let { rootNode = null } = $$props;
  let { passthrough = null } = $$props;
  let { beforeRouterInit = null } = $$props;
  let { afterRouterInit = null } = $$props;
  let { beforeUrlChange: beforeUrlChange2 = null } = $$props;
  let { afterUrlChange: afterUrlChange2 = null } = $$props;
  let { transformFragments = null } = $$props;
  let { onDestroy: onDestroy2 = null } = $$props;
  let { plugins = null } = $$props;
  let { queryHandler = null } = $$props;
  let { anchor = "wrapper" } = $$props;
  let { clickHandler = {} } = $$props;
  const context2 = {
    childFragments: writable([]),
    decorators: [normalizeDecorator(ScrollDecorator_default)]
  };
  const options = {
    instance: instance8,
    rootNode,
    name,
    routes,
    urlRewrite,
    urlReflector,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  };
  if (!router)
    router = new Router(options);
  const initialize = (elem) => {
    elem = anchor === "parent" || anchor === "wrapper" ? elem : elem.parentElement;
    router.setParentElem(elem);
    elem["__routify_meta"] = { ...elem["__routify_meta"], router };
    let clickScopeElem = resolveIfAnonFn((clickHandler == null ? void 0 : clickHandler.elem) || elem)(elem);
    if (!router.passthrough) {
      clickScopeElem.addEventListener("click", handleClick);
      clickScopeElem.addEventListener("keydown", handleClick);
    }
  };
  const handleClick = (event) => {
    var _a;
    let url3 = getUrlFromClick(event);
    url3 = ((_a = clickHandler.callback) == null ? void 0 : _a.call(clickHandler, event, url3)) ?? url3;
    if (typeof url3 === "string")
      router.url.push(url3);
  };
  if (typeof window !== "undefined")
    onDestroy(() => router.destroy());
  const writable_props = [
    "router",
    "routes",
    "decorator",
    "urlReflector",
    "instance",
    "urlRewrite",
    "url",
    "name",
    "rootNode",
    "passthrough",
    "beforeRouterInit",
    "afterRouterInit",
    "beforeUrlChange",
    "afterUrlChange",
    "transformFragments",
    "onDestroy",
    "plugins",
    "queryHandler",
    "anchor",
    "clickHandler"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
  };
  $$self.$capture_state = () => ({
    Router,
    _onDestroy: onDestroy,
    getUrlFromClick,
    resolveIfAnonFn,
    Component: ComposeFragments_default,
    ScrollDecorator: ScrollDecorator_default,
    get: get_store_value,
    writable,
    AnchorDecorator: AnchorDecorator_default,
    normalizeDecorator,
    router,
    routes,
    decorator,
    urlReflector,
    instance: instance8,
    urlRewrite,
    url: url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    anchor,
    clickHandler,
    context: context2,
    options,
    initialize,
    handleClick,
    activeRoute: activeRoute2,
    $activeRoute
  });
  $$self.$inject_state = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
    if ("activeRoute" in $$props2)
      $$subscribe_activeRoute($$invalidate(3, activeRoute2 = $$props2.activeRoute));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*url, router*/
    2112) {
      $:
        if (url2 && url2 !== router.url.internal())
          router.url.replace(url2);
    }
    if ($$self.$$.dirty & /*router*/
    64) {
      $:
        $$subscribe_activeRoute($$invalidate(3, activeRoute2 = router.activeRoute));
    }
    if ($$self.$$.dirty & /*$activeRoute*/
    4) {
      $:
        context2.childFragments.set(($activeRoute == null ? void 0 : $activeRoute.fragments) || []);
    }
    if ($$self.$$.dirty & /*router*/
    64) {
      $:
        router.log.debug("before render", get_store_value(context2.childFragments));
    }
  };
  return [
    decorator,
    anchor,
    $activeRoute,
    activeRoute2,
    context2,
    initialize,
    router,
    routes,
    urlReflector,
    instance8,
    urlRewrite,
    url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange2,
    afterUrlChange2,
    transformFragments,
    onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  ];
}
var Router_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment8, safe_not_equal, {
      router: 6,
      routes: 7,
      decorator: 0,
      urlReflector: 8,
      instance: 9,
      urlRewrite: 10,
      url: 11,
      name: 12,
      rootNode: 13,
      passthrough: 14,
      beforeRouterInit: 15,
      afterRouterInit: 16,
      beforeUrlChange: 17,
      afterUrlChange: 18,
      transformFragments: 19,
      onDestroy: 20,
      plugins: 21,
      queryHandler: 22,
      anchor: 1,
      clickHandler: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_1",
      options,
      id: create_fragment8.name
    });
  }
  get router() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set router(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorator() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlReflector() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlReflector(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlRewrite() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlRewrite(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootNode() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rootNode(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transformFragments() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformFragments(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plugins() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router_1;

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js
var LocalStorageReflector = class extends BaseReflector {
  /** @param {Router} router */
  constructor(router) {
    super(router);
    this.storageName = `__routify-router-${this.router.name}`;
  }
  reflect() {
    window.localStorage.setItem(this.storageName, this.router.url.internal());
  }
};

// node_modules/@roxi/routify/lib/runtime/helpers/index.js
var getMRCA = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  return lineage1.find((node3) => lineage2.includes(node3));
};
var getPath = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  const mrca = getMRCA(node1, node2);
  const backtrackSteps = lineage1.indexOf(mrca);
  const backtrackStr = backtrackSteps ? "../".repeat(backtrackSteps) : "";
  const forwardSteps = lineage2.indexOf(mrca);
  const forwardStepsStr = lineage2.slice(0, forwardSteps).reverse().map((n) => n.name).join("/");
  return backtrackStr + forwardStepsStr;
};
var goto = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    return derived(url, ($url) => (path, userParams, options) => {
      const defaults2 = { mode: "push" };
      options = { ...defaults2, ...options };
      const newUrl = $url(path, userParams);
      router.url[options.mode](newUrl);
    }).subscribe(run, invalidate);
  }
};
var url = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    const originalOriginNode = contexts.fragment.node;
    return derived(router.activeRoute, (activeRoute2) => {
      const originNode = router.rootNode.traverse(originalOriginNode.path);
      return (inputPath, userParams = {}) => {
        const offset = inputPath.startsWith("/") ? router.rootNode.path : "";
        const targetNode = originNode.traverse(offset + inputPath);
        if (!targetNode) {
          console.error("could not find destination node", inputPath);
          return;
        }
        const mrca = getMRCA(targetNode, router.rootNode);
        const path = ("/" + getPath(mrca, targetNode)).replace(/\/index$/, "/");
        const params2 = {
          ...inheritedParams(targetNode, activeRoute2),
          ...userParams
        };
        const internalUrl = populateUrl(path, params2, activeRoute2);
        return router.getExternalUrl(internalUrl);
      };
    }).subscribe(run, invalidate);
  }
};
var inheritedParams = (node2, route) => {
  const lineage = [node2, ...node2.ancestors].reverse();
  const params2 = lineage.map(
    (_node) => {
      var _a;
      return (_a = route.allFragments.find(
        // compare both path and node
        // node could have moved /shop/[product], eg: to /en/shop/[product]
        // but could also have been replaced by a different, but matching node
        // if the route tree changed, eg: /en/shop/[product] /da/shop/[product]
        (fragment) => fragment.node === _node || fragment.node.path === _node.path
      )) == null ? void 0 : _a.params;
    }
  );
  return Object.assign({}, ...params2);
};
var params = {
  subscribe: (run, invalidate) => derived(contexts.router.params, (params2) => params2).subscribe(run, invalidate)
};
var isActive = {
  subscribe: (run, invalidate) => derived(contexts.router.activeRoute, isActiveRoute).subscribe(run, invalidate)
};
var isActiveRoute = ($route) => isActiveUrl($route.url, $route.params);
var isActiveUrl = (url2, actualParams = {}) => {
  const stripLastIndexAndSlash = (str) => str.replace(/(\/index)?\/*$/, "");
  url2 = url2.replace(/[?#].+/, "");
  url2 = stripLastIndexAndSlash(url2);
  return (path, params2 = {}, options = {}) => {
    const { recursive } = { recursive: true, ...options };
    for (const wantedParam of Object.keys(params2))
      if (actualParams[wantedParam] !== params2[wantedParam])
        return false;
    path = pathAndParamsToUrl(path, { ...actualParams, ...params2 }, (x) => "", true);
    path = stripLastIndexAndSlash(path);
    const suffix = recursive ? "(/|$)" : "/?$";
    const regexPath = new RegExp(`^${path}${suffix}`);
    return regexPath.test(url2);
  };
};
var resolveNode = (path) => {
  const { node: node2 } = contexts.fragment;
  const { router } = contexts;
  return traverseNode(node2, path, router);
};
var traverseNode = (node2, path, router) => path.startsWith("/") ? router.rootNode.traverse(`.${path}`) : node2.traverse(path);
var pseudoStore = (callback) => ({
  subscribe: (run) => {
    run(callback());
    return () => {
    };
  }
});
var context = pseudoStore(() => contexts.fragment);
var node = pseudoStore(() => get_store_value(context).node);
var meta = pseudoStore(() => get_store_value(node).meta);
var activeRoute = {
  subscribe: (run) => contexts.router.activeRoute.subscribe(run)
};
var pendingRoute = {
  subscribe: (run) => contexts.router.pendingRoute.subscribe(run)
};
var afterUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.afterUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};
var beforeUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.beforeUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};

// node_modules/@roxi/routify/lib/common/helpers.js
var gentleAssign = (target, ...sources) => {
  sources.forEach(
    (source) => Object.keys(source).forEach((key) => target[key] = target[key] ?? source[key])
  );
  return target;
};
var assignNode = (target, ...sources) => {
  gentleAssign(target, ...sources);
  gentleAssign(target.meta, ...sources.map((s) => s.meta));
  sources.forEach((source) => {
    source.children.forEach((sNode) => {
      let tNode = target.children.find((tNode2) => tNode2.name === sNode.name);
      if (!tNode)
        tNode = target.createChild(null, null);
      assignNode(tNode, sNode);
    });
  });
  return target;
};
var findNearestParent = (node2, callback) => {
  let parent = (
    /** @type {RNodeRuntime} */
    node2.parent
  );
  while (parent) {
    if (callback(parent))
      return parent;
    parent = parent.parent;
  }
};
var getDistance = (parentNode, childNode) => {
  let child = null;
  let distance = 0;
  while (child = childNode.parent) {
    distance++;
    if (parentNode === childNode)
      return distance;
  }
};

// node_modules/@roxi/routify/lib/runtime/index.js
var Routify2 = RoutifyRuntime;
export {
  AddressReflector,
  ComposeFragments_default as Component,
  InternalReflector,
  LocalStorageReflector,
  Router_default as Router,
  Router as RouterClass,
  Routify2 as Routify,
  activeRoute,
  afterUrlChange,
  appInstance,
  assignNode,
  beforeUrlChange,
  context,
  createRouter,
  findNearestParent,
  getDistance,
  getMRCA,
  getPath,
  getScrollBoundaries,
  goto,
  isActive,
  isActiveRoute,
  isActiveUrl,
  meta,
  node,
  params,
  pendingRoute,
  persistentScopedScrollIntoView,
  resolveIfAnonFn2 as resolveIfAnonFn,
  resolveNode,
  scopedScrollIntoView,
  scrollToContext,
  traverseNode,
  url
};
//# sourceMappingURL=@roxi_routify.js.map
